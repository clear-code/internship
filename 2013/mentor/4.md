# メンターのインターンシップメモ: 2013-06-24

4日目。9:30くらい-18:00。

以下を実施した。

- groongaデータベースの作成
- Travis CIでgroongaコマンドを使う
- privateメソッドをテストするべきかどうかの説明
- テスト用の一時ファイルの削除について
- テスト用の一時ファイルの扱いについて
- テスト時にwarningをだす
- groongaデータベースへのデータ投入
- WebアプリのUIの検討

## groongaデータベースの作成

前回の作業でgroongaデータベースのスキーマを作るところまでいったので、実
際に
[スキーマをgroongaのデータベースに投入](https://github.com/ranguba/epub-searcher/commit/058ecdb1e6668ecac3f81580839014143c10751b)
した。

作業を始める前に以下の点について基本的な方針を説明した。

- groongaのコマンドラインオプションについて
- スキーマが定義されたかどうかの確認方法について
- Rubyから外部プロセスを呼ぶ方法について

groongaコマンドで新規にデータベースを作成する場合は-nオプションを指定す
る必要がある。ただし、すでにデータベースが存在するのに-nオプションを指
定するとエラーになるため気をつける必要がある。

スキーマがどのように定義されたかはgroongaのdumpコマンドで確認できる。
「groonga DB_PATH dump」とすることでデータベースの中身をgroongaコマンド
形式で出力する。これが期待通りの結果かを文字列比較すればよい。

今回の作業ではgroongaを外部プロセスとして実行するため、Rubyから外部プロ
セスを実行する方法について説明した。Rubyで外部プロセスを実行する場合、
主に以下の3種類の方法がある。

- \`...\`（バッククォート）
- system
- spawn

他にもopen3などがあるがspawnで事足りるため説明は省略した。

まず、バッククォートとsystemについて説明した。

これらの大きな違いは返り値である。バッククォートは標準出力に出力された
内容を文字列で返すのに対し、systemは終了ステータスが0かどうかの真偽値を
返す。systemでは外部プロセスが標準出力に出力したらそのまま出力される。
テストでは外部プロセスの出力結果を使いたいことが多いので、テストではバッ
ククォートが便利である。

それほど大きくないが使い勝手に影響を与える違いはシェルに解釈させないよ
うにできるかどうかである。バッククォートの場合は必ずシェルに解釈される
ため、引数にスペースを含む場合などは事前にエスケープしてから渡す必要が
ある。systemの場合は `system("ls", "Program Files")` というように複数の
引数として渡せばシェルに解釈させないようにできる。シェルの解釈を考慮し
なくてよくなるため、systemのこの機能は便利である。もし、標準出力に何も
出力しない外部プロセスをライブラリー中で起動するなら、systemを使う方が
よい。ライブラリー中でバッククォートを使う場合はセキュリティーリスクも
考慮する必要がある。例えば、以下のようなコードは危険である。

    directory = gets.chomp
    files = `ls #{directory}`

`/tmp; cat /etc/passwd` と入力されると/etc/passwdファイルの中身が返って
くる。Shellwordsモジュールを使って入力値をエスケープするべきである。

バッククォートとsystemの同じ点にも説明した。これらはどちらも同期で実行
される。つまり、外部プロセスが終了するまで結果が返ってこないということ
である。これは、テストで使う場合に便利である。

一方、spawnは非同期で実行される。つまり、外部プロセスを起動したらすぐに
処理が返ってくる。外部プロセスとやりとりする場合は非同期で実行する
spawnが必要になる。外部プロセス起動中にスクリプトの処理を実行する必要が
あるからである。

今回はライブラリー中ではgroongaプロセスと標準入出力で通信するためspawn
を使う。一方、テストでは `groonga DB_PATH dump` の出力結果だけを使うの
でバッククォートを使う。

## Travis CIでgroongaコマンドを使う

手元ではテストがパスするのに
[Travis CI上では失敗](https://travis-ci.org/ranguba/epub-searcher/builds/8375935)
するようになった。これは、Travis CI上にはgroongaがインストールされてい
ないからである。

[Travis CI上にgroongaをインストール](https://github.com/ranguba/epub-searcher/commit/8503d90b952aaf7b477861d4e3174f2577457450)
するようにして解決した。参考: [groongaのドキュメント](http://groonga.org/ja/docs/development/travis-ci.html)

この件に関連して、テスト環境上で使えないもの（例えばgroonga）があっても
テストが実行できるように、たとえ自動生成できるファイル（例えばgroongaの
データベース）であってもフィクスチャーとしてリポジトリーに入れておいた
ほうがよいのか、という質問があった。

答えはnoである。テスト環境はできるだけ実際に動かす環境と同じようにする
べきである。そうしないと問題を見つけにくくなるからである。テストは問題
を見つけるためにやっているので、問題を見つけにくくすることは避けるべき
である。よって、できるだけテスト環境では必要なものを使えるようにすると
いう対応をしたほうがよい。

## privateメソッドをテストするべきかどうかの説明

privateメソッドはどうやってテストをするのかという質問があった。

まず、そもそもこのprivateメソッドをテストするべきかどうかということを考
えるとよいということを説明した。テストするかどうかは「privateメソッドの
量が多いか」を基準として考えるとよい。量が少なければpublicメソッドをテ
ストするだけでprivateメソッドでの処理を網羅しているだろうからprivateメ
ソッドを明示的にテストする必要はない。量が多い場合は、privateメソッドで
やっている処理をクラスとしてくくりだし、そのクラスのpublicメソッドとす
る。テストはそのpublicメソッドに対して実施する。くくりだされたクラスで
は、くくりだしたクラスのインスタンスを作成して処理をする。

今回のケースではprivateメソッドの量が少なかったので特にテストを用意しな
いことにした。

## テスト用の一時ファイルの削除について

groongaのデータベースを作るテストを実行するとデータベースができて、次回
実行時にデータベースを新規で作れなくなる。そのため、テストを実行した後
に手動でデータベースを削除する必要がある。これは避けるべきである。

できるだけ自動でテストを実行できるようにし、さらに、毎回同じ状態でテス
トを実行できるようにするべきである。これは、再現性を高めるためである。
問題が発生したとき、簡単に問題を再現させることができれば調査に役立つ。
自動化されていればより簡単になる。そのため、できるだけ自動化しておくこ
とが重要である。

テスティングフレームワークにはsetup/teardownまたは類似の仕組みがあり、
テスト実行前後に処理を実行できる。普通に考えるとteardownでデータベース
を削除して対応完了としたくなるが、setupにもデータベースを削除するコード
を入れておくことが望ましい。もしかしたら、前回のテスト実行時にteardown
中に例外が発生してデータベースを削除していないかもしれないからである。
念のためsetupでもデータベースを削除していれば、そのようなケースでもクリー
ンな状態でテストを実行できる。

## テスト用の一時ファイルの扱いについて

テスト用の一時ファイルは開発時に使う場所とは別の場所に置くべきである。
今回の場合では、テスト用のデータベースは何度も消されても問題ない場所に
置き、開発時に使うデータベース（コマンドラインからデータを登録するとき
などに使用）とは別の場所に置く。なぜなら、開発用のデータベースは手動で
の動作確認用に便利でよく使うのに、何度も1から作りなおさなければいけない
と不便になってしまうからである。

Railsでもdevelopment環境用のデータベースとtest環境用のデータベースを分
けている。これと同じことである。

テスト用の場所を分ける方法には以下の方法がある。

- テスト用の値を設定するAPIを用意する
- 環境変数を参照する

テスト用の値を設定するAPIを用意すると、通常のプログラムで使っている値を
そのまま設定できるため便利なことが多いが、不必要なAPIが外に見えてしまう
のが気持ち悪い。影響範囲が小さいのであれば有効である。

環境変数を参照するのはRailsでもやっている方法である。Railsでは
RAILS_ENVという環境変数を使っている。環境変数では文字列しか渡せないがプ
ログラム全体からグローバルに参照できるため、参照しやすいというメリット
がある。なお、groongaでも環境変数を参照して、テスト時はmake installしな
くてもプラグインをロードできるようにしている。

今回は影響範囲が小さいため
[テスト用の値を設定するAPIを用意](https://github.com/ranguba/epub-searcher/commit/683d418fa5852c656ae02e351f8e48924151d32d)
した。

## テスト時にwarningをだす

通常利用の場合はwarningを出さなくてもよいが、テストを実行しているときは
Rubyのwarningを有効にするとよい。テストでは問題を見つけることが目的だか
らである。

今回は[テスト実行時のRubyのコマンドライン引数に-wを追加](https://github.com/ranguba/epub-searcher/commit/32972578613637881b51c574327736f66308c0ef)
した。

warningを有効にしたところEPUB Parserにwarningが見つかったので、
[Pull Request](https://github.com/KitaitiMakoto/epub-parser/pull/3)をだ
した。これは、開発中に見つけた問題はたとえ他のプロジェクトの問題であっ
ても修正するという
[クリアコードの開発スタイル](http://www.clear-code.com/philosophy/development/style.html)
に沿うものである。違う人が同じ問題にあわずに済むようにするためである。

## groongaデータベースへのデータ投入

[loadコマンドを使って実現](https://github.com/ranguba/epub-searcher/commit/184715adbf4d599dfd73403cbb1af02284e3e181)
した。

loadコマンドについては入力フォーマットについて簡単に説明しただけである。

## WebアプリのUIの検討

TODO: ...
