# メンターのインターンシップメモ: 2013-07-11

11日目。9:30 - 17:00。

以下を実施した。

- 今後の開発方針の説明を聞く
- fluent-plugin-droongaでtable_createコマンドをrroongaのAPIに変換
- table_createコマンドのフラグをパースする処理をgroogna-commandで実装

## 今後の開発方針の説明を聞く

森さんからdroongaのアーキテクチャをこうしたいという話を聞いた。ピンとき
ていないようだったが質問はしていなかった。森さんからの説明の後に、特に
補足した説明はしなかった。

質問しなかったのは、わからないことばかりで何から聞けばわからなかったか
ら、あるいは、初歩的なことを質問するのは気が引けるから、などと考えてい
たのではないだろうか。しょうがないと思う。

補足の説明をしなかったのは、アーキテクチャレベルの大きなことをわかって
いなくても作業できるように、都度説明をしていこうと思っているからという
のが理由の1つ。アーキテクチャにはそんなに興味はないのではないか（具体的
にどうプログラムを書くかの方が興味ありそう）と感じたので、掘り下げたり
理解を助けたりする必要はないのではないかと思ったのが別の理由。

補足の説明をした方がよかっただろうか。。。

### fluent-plugin-droongaでtable_createコマンドをrroongaのAPIに変換

前回に引き続き、
[groongaのtable_createコマンド](http://groonga.org/ja/docs/reference/commands/table_create.html)
の引数をパースして対応するrroongaのAPIに変換していく作業を進めた。他の
作業をしないといけなかったので、基本的に一人で作業を進めてもらった。

[引数の種類ごとにメソッドをわけた](https://github.com/groonga/fluent-plugin-droonga/commit/4ace99343a0f1789366ac443ae6037f6b72a477d)
のはよかった。あと、一緒にテストもコミットしているのもよい。

ただ、 `parse_request` の中で `options.merge!` を繰り返し使っていること
が気になった。

#### 破壊的メソッドとテスト

今回は、 `parse_request` の中で `options.merge!` を呼ぶことをやめ、
`parse_request` で破壊的に変更していた `options` を各 `parse_XXX` に
[移動](https://github.com/groonga/fluent-plugin-droonga/commit/83324f8bc194a0379318de980fd841ab4b253277)
した。以下の理由からこうした方がすっきりすると判断した。

- `paprse_request` をみれば、一連の `parse_XXX` が同じ `options` を操作していることがより明確になる。

ただし、以下のような懸念点もある。

- 各 `parse_XXX` だけみると、 `options` にどんな値が入っているのかが気になる。

よく見れば、 `options` には値を設定しているだけで参照はしていないので
`options` にすでにどんな値が入っていても関係ないが、 `options` を引数と
して渡してしまうとそれがわかりにくくなってしまう。 `options` を各
`parse_XXX` で作る場合は空の状態からはじめるのでそこで迷うことはない。


一般的に、速度が気にならない場面では、破壊的なメソッドよりも生成した新
しいオブジェクトを返すような非破壊的なメソッドの方が好ましい。これは、
以下の理由からである。

- 破壊的なメソッドの場合は、呼び出す毎にオブジェクト自身が変わるため、
  意図せずに共有しているオブジェクトを変更してしまい、見つけにくい問題
  になることがある
- 非破壊的なメソッドの場合は、メソッドの入力（引数）と出力（返り値）の
  ペアでテストすればよいため、破壊的なメソッドよりもテストを書きやすい
  場合が多い。破壊的なメソッドの場合はメソッドを呼んだ後に別のなんらか
  の方法で期待した動作をしたかを確認しないといけない。

ただし、影響が限定的な場合は破壊的なメソッドにした方がすっきりする場合
がある。今回は、それぞれのプライベートな `parse_XXX` をテストしているの
ではなく、もう少し上のレイヤーの「 `table_create` 用の引数を入力として、
その結果、データベースに適切なテーブルが定義されているか」をテストして
いる。そのため、 `parse_request` は完全に実装の詳細となっている。

今回破壊的に変更している `options` は `parse_request` 内で生成して返し
ているオブジェクトである。つまり、破壊的に変更しているといっても、
`parse_request` 内という限定的な範囲であるため、意図しない箇所でオブジェ
クトが変更されていることにはすぐに気付ける。よって、ここでは破壊的な処
理を行なっても大きなデメリットとなることはない。

破壊的な操作をするときは、その影響範囲が大きいかどうかを考慮するとよい
だろう。テスト対象になるような公開されたAPIではと特に注意が必要である。

### table_createコマンドのフラグをパースする処理をgroogna-commandで実装

`table_create` コマンドの `flags` 引数の値をパースする処理はdroongaに依
存しない一般的な機能なので、groonga-commandに実装を移動することにした。

コマンドの引数の値を使いやすいようにするAPIに関する作業は初めての作業だっ
たので一緒に作業した。最初にコンセプトを示すために一連の作業を荒いコー
ドを書きながら、こんな感じと説明した。その後、一連の作業を整理し、分離
してひとつずつの小さな単位としてコミットしていこうとしたところ、うまく
できないと思っていることを1つ相談してもらえた。前回の日のメモの「考えた
こと」に書いていたことだと思う。

#### コミットメッセージを書く作業の負担が大きい

ひとりで作業をしているときに、何コミット分（複数の変更）も書いてしまっ
てからコミットしようとして、一度stashしてそこから1コミット分を取り出し
ながらコミットしてしまう、ということであった。話を聞いていくと、コミッ
トメッセージを書く作業が一仕事で、1つコミットしているとその後にやろうと
していた作業を忘れてしまう、そのため、何コミット分も最初に書いてしまう
ということだった。

では、自分はどうしているのかということを考えてみた。もしかしたら、コミッ
トメッセージに書く内容のパターンをいくつかイディオムとして持っていて、
すぐにコミットメッセージを書き終わることができるなのかもしれないと考え
た。しかし、本当にそうなのかピンとこなかったので、実際に
[荒く書いた一連のコードを分割してコミットしてみた](https://github.com/groonga/groonga-command/compare/e43e6963e39026e5426131dec85e82e776a0e1d2...2a2c46ef56834e5b86f1efefb992dd28128c22b9)
。

実際にやってみたところ、関連する作業をしているときは以前のコミットメッ
セージを使って新しいコミットメッセージを書いていた。（magitでコミットメッ
セージを書くときはM-n/M-pで過去のメッセージを取り出せる。）ということで、
コミットメッセージのパターンを持っているというよりも、過去のコミットメッ
セージを使うことでコミットメッセージを書くのが楽になっていた。コミット
メッセージを楽に書けると、次にしようと思っていた作業を忘れずに済むため、
何コミット分もコードを書きためてからコミットしなくても済むようになるだ
ろう。

#### 何をテストすればよいか

フラグの値によって結果が変わるため、フラグの値によって複数のテストを書
く必要がある。このとき、このインターンシップ中にすでに何度かでてきた何
をテストすれば十分か、という話がまたでてきた。

ポイントは、境界はどの値か、同じクラスターと考えられる値はどの値かを見
極めることである。フラグの取りうる値は以下のとおりである。

- `TABLE_NO_KEY`
- `TABLE_HASH_KEY`
- `TABLE_PAT_KEY`
- `TABLE_DAT_KEY`
- `KEY_WITH_SIS`

`TABLE_XXX` となっているのがテーブルの種類を指定するフラグで、
`KEY_WITH_SIS` がキーをどのように使うかのオプションである。

[`TABLE_NO_KEY` が指定されたかどうかを返すメソッドのテストをしたい場合](https://github.com/groonga/groonga-command/commit/d83c7671dd0468532f9ce17a6f767287fc5da5ae)
を考える。境界をどこに設定するか、同じクラスターをどこに設定するかで以
下のようにいくつか考え方がある。

- すべてバラバラの値と考える（境界値はすべての値で、すべて違うクラスター）
- `TABLE_XXX` が同じクラスターで `KEY_WITH_SIS` が違うクラスターと考える。（境界値は…連続値じゃないので境界はない。）

今回はすべてバラバラの値と考えた。これは、 `TABLE_NO_KEY` が指定された
かと他のフラグが指定されたかは独立しているからである。よって、今回は
`TABLE_NO_KEY` が指定された場合と違う値が指定された場合のテストだけ用意
した。

ただし、エラー処理のことを考えるとそうでもない。 `TABLE_NO_KEY` と他の
`TABLE_XXX` を指定していたらエラーにしたい。ただ、それは、この
「 `TABLE_NO_KEY` が指定されたかどうかを返すメソッド」
（ `table_no_key?` ）のテストではなく、フラグの値をパースしているメソッ
ドのテストとするべきだろう。そうすると、 `table_no_key?` ではなく、妥当
な値が設定されているという前提で動くことができるため、やはり、
`TABLE_NO_KEY` の場合と他の値が設定されている場合の2パターンのテストで
十分だろう。

#### データ駆動テスト

`table_no_key?` のテストで2つのパターンが必要なことがわかった。同じメソッ
ドに対して複数のパターンがあるときは、そのメソッドをキーとしてテストを
まとめるとテストがすっきりする。そのための方法としてこれまでテストのグ
ループ化を使っていたが、今回はデータ駆動テストを使うことにした。

- データ駆動テスト: 参考: [Ruby用単体テストフレームワークtest-unitでのデータ駆動テストの紹介](http://www.clear-code.com/blog/2013/1/23.html)
- テストのグループ化: 参考: [テストをすっきり書く方法](http://www.clear-code.com/blog/2012/4/25.html)

これは、メソッドの使い方は変わらず、入力と出力、つまりデータ、だけが変
わるケースだからである。テスト方法（メソッドの呼び出し順や、事前処理の
方法など）が変わるときはテストをグループ化して別々のテストメソッドを定
義する方が読みやすいが、テスト方法は同じでテストデータだけが変わる場合
はデータ駆動テストの方が大事なところ（このテストで何に注目しているか）
に集中できる。

今回の場合は、データ駆動テストをするには大げさな気もしたがデータ駆動テ
ストを使った。

test-unitのデータ駆動テストのAPIでは `data` メソッドでテストデータを設
定するが、そのデータの有効範囲をちゃんと説明しなかったところ、
[同じテストケース内の全てのテストでデータを共有すると思った](https://github.com/groonga/groonga-command/commit/91f9d6093b90c8479add2f1cf376ee227560c568)
ということだった。もしかしたら、 `data` メソッドはあんまりよいAPIじゃな
いかもしれない。。。

## その他

- 問題が起こった現場に立ちあうと相談してもらいやすい気がする。（なので、問題を把握するためには一緒に作業するのが有効っぽい。）
- 自分がどうやっているかは、自分がどうやっているかを意識しながら実際にやってみないとわからない。他の人に自分がどうやっているかを見ておいてもらうのもいいのかもしれない。ただ、他の人に頼むときは、何をやっているのか分析するのがうまい人というか盗むのがうまい人に頼まないと難しそう。
- 何をテストすればよいか（何をテストしないか）はむずかしいだろうなぁと思う。ピンとくるにはいろんなケースを経験するしかないのだろうか。
- データ駆動テストのAPIは…どうするのがよいだろう…
