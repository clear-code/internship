# メンターのインターンシップメモ: 2013-07-04

8日目。9:30 - 18:00。

以下を実施した。外出していたためあまり見れなかった。よくない。

- groonga-clientの整理

## groonga-clientの整理

groonga-clientの整理を再開した。前回の最後にこのあたりを整理したほうが
よいというのを簡単に伝えており、それらを実際に整理することにした。

簡単なものから順に実施することにした。

### コードを変更する前に既存のテストをパスした状態にする

件数を返すメソッドの名前を `total_XXX` から `n_XXX` にすることからはじ
めることにした。 `n_XXX` にしたのはrroongaでは `n_XXX` というメソッド名
を使っているからである。

関連するライブラリと同じ命名規則を使うことはよいことである。なぜなら、
ユーザーに統一感のAPIを提供できるからである。APIに統一感があると同じこ
とをするために同じように書けるため、読んだときに考えることが少なくなり
理解しやすくなる。また、同じことをするために書き方を使い分ける必要がな
くなるため、書きやすくもなる。

`n_XXX` にしようとしたところ、既存のテストをパスさせるためには追加の変
更が必要だとわかった。そこで、まずは、既存のテストをパスさせることを優
先した。その時点の作業は `git stash` で退避した。

本体のコードを変更する前に既存のテストをパスした状態にすることは重要で
ある。なぜなら、コードの変更が原因でテストがパスしたかどうかわかりやす
くなるからである。変更する前にテストがパスしていて変更後にテストがパス
しなくなったのならその変更が原因である。変更前からテストがパスしていな
かったのなら、今回の変更が原因か今回の変更に関係なく失敗していたのかわ
からない。そうすると、テストが失敗する原因を調べる範囲が広くなり、原因
が見つかるまでに手間がかかる。よって、コードを変更する前に既存のテスト
をパスした状態にすることおよびパスした状態であることを確認することが望
ましい。

今回は変更前からテストが失敗していたので、まず
[テストをパスするようにした](https://github.com/ranguba/groonga-client/commit/2711b8145be6b80ed64de518a8733324eb4a4ae4)
。その後、
[名前を変更した](https://github.com/ranguba/groonga-client/commit/d96313d11a4883d5d103fe273eb7e0d4dae9de42)
。

### 一連の作業をしているときは次にやることをコミットメッセージに書く

次に、ドリルダウン結果をパースするメソッドとして
[専用のメソッドを用意した](https://github.com/ranguba/groonga-client/commit/5b892a8ccafb522c351837ac154f3e1e5e14be69)
。これは、ドリルダウン結果をパースする処理は検索結果をパースする処理と
は別の処理であることがわかったためである。ただし、まずは名前をつけるだ
けで実装は既存のメソッドを呼び出すだけにした。そして、コミットメッセー
ジにこの後メソッドの実装を修正していくことを付け加えた。

作業中であることを示すために「WIP」（Work In Progress。作業中の意。）な
どの印をつけ、コミットを読んだ人に作業中であることを伝える方法がある。

これは何もつけないよりよいコミットメッセージである。作業中である場合は、
機能が不足していたり、エラー処理が考慮されていないなど、不完全な状態の
コミットになる。(*)不完全な状態のコミットを読んだとき、作業中であるとわ
からなければこれは○○という問題がありそう、などとコメントしたくなる。
もし、コミットした人がそれを考慮済みの場合は「それはわかっている」とコ
メントを返すだろう。そんなコメントが返ってきたら、「最初から教えてよ。
それならコメントしなかったのに。」となるだろう。これでは、コメントする
側が「これはコメントした方がよいかなぁ。すでに知っていることだったらコ
メントしたくないなぁ。今回は（も）やめておこう。」となって、コードを書
いている人に違った視点を提供する機会が減ってしまう。これはもったいない
ことである。そのため、コメントしやすくするという意味で事前に情報を伝え
ることは重要である。

(*) それでも、テストが通らない状態やそもそもビルドが通らない状態にす
るべきではない。開発中の機能が不完全なだけでソフトウェア自体は動く状態
を維持することが望ましい。そうしないと、一緒に開発している人が動作を確
認したりすることができない。

ただし、WIPのように作業中であることだけを示すよりも、
[今回のコミット](https://github.com/ranguba/groonga-client/commit/5b892a8ccafb522c351837ac154f3e1e5e14be69)
のように具体的にこのあと何をする予定かを書くほうが望ましい。なぜなら、
WIPではそのあとどのような作業が残っているかがわからないからである。考慮
していないことに対するコメントも「作業中ならコメントは控えておくか」と
なってしまう可能性がある。

また、WIPだけでは、もし、そのあとよくない方向に進もうとしていてもコミッ
トを読んだ人が止めることはできないという点も忘れてはいけない。これは、
実際によくない方向に進んだコミットを読んでからしかよくない方向に進んだ
かわからないからである。

しかし、WIPだけではなく具体的にこのあとどうするつもりかを書いておけば、
そのコミットを読んだ時点でよくない方向に進もうとしているかどうかがわか
る。もし、よくない方向に進みそうならコメントして、その方向で本当によい
か検討することもできる。

よって、一連の作業をしていて、その後何をするかがわかっている場合はコミッ
トメッセージにそれについて書いておくことが望ましい。

### ひとつのコミットでひとつの変更を

その後、
[検索結果をパースしているメソッドの名前も適切な名前に変更した](https://github.com/ranguba/groonga-client/commit/220a97881a100bf93d64c2028d48467755cc423b)
。このとき、引数名も一緒に適切な名前に変更しようとしたが、これではひと
つのコミットに複数の変更が入ることに気づき、
[別のコミットにした](https://github.com/ranguba/groonga-client/commit/a1f6e21d59c0584d05d6c083fe6715128b8cb294)
。

ひとつのコミットではひとつの変更をする、という習慣が身についてきている
と感じた。

### 外出中

このあたりは外出していたため、作業の様子は見ていない。

- [一般的な名前ではなく、コマンドに応じて適切な名前を使うようにする変更](https://github.com/ranguba/groonga-client/commit/7ccb67adfee6fc13126ab78fe92de6c695614070)。
- [テスト用データを定数からインスタンス変数にする変更](https://github.com/ranguba/groonga-client/commit/0c9b03d31cf7d82294ee7fc3659b473ed9322cdb)
- 他...

テスト用データに関して補足する。

テスト用データは定数にするよりインスタンス変数にする方がよい。これは以
下の2つの理由からである。

- 定数の場合は他のオブジェクトから参照できる。
- 定数の場合はテスト内でうっかり内容を変更してしまうと他のテストに影響を与えてしまう。

最初の参照できる点について補足する。

あるテストケース内でのみ使うデータは他のテストケースからは参照できる必
要はない。不必要にアクセスできる範囲を広げると、意図しない依存関係がで
きてコードの変更がしづらくなってしまう可能性がある。よって、必要ないな
ら参照できるようにしなくてよい。

もし、複数のテストケースで参照したい場合はモジュールに定義し、各テスト
ケースではそれを参照するようにすればよい。Rubyのモジュールは実装を共有
するための仕組みなので、この方がRubyらしい用途にあった使い方である。

今回はこちらの理由がしっくりきたということなので、コミットメッセージに
はこちらの理由が書かれている。

2番目の他のテストに影響する点について補足する。

定数にすると定義時のみ値を初期化する。一方、テストケースのインスタンス
変数にするとテスト毎に値を初期化する。テストは他のテストに影響を与えず
に実行できる（独立である）べきである。これは、テストが失敗したときに簡
単に再現できるからである。簡単に再現できると問題の原因を調査するときに
役立つ。

テスト毎に値が初期化されると万が一テスト内で値を変更してしまったとして
も他のテストには影響を与えない。これはテストを独立させる点からみると望
ましい挙動である。

ただし、値を生成するコストが増える。値が文字列や配列であれば気にするこ
とはないが、もし、値を生成するコストが大きければ定数にするなど一度だけ
値を生成するようにすることを検討するべきである。これは、値を生成するコ
ストが大きく、テスト実行時間が長くなったりするとテストを実行するのが億
劫になったり、問題を再現するコストが大きくなりデバッグの効率が落ちるか
らである。テストを実行するのが億劫になり、テストを実行しなくなると、テ
ストの価値がなくなってしまう。これは避けなければいけない。問題の発見が
遅くなり、問題が発覚したときに調べる範囲が広がり、問題解決のコストがあ
がってしまう。

### テストするところ

外出から帰ってきて様子を聞いたところ、コマンドを実行するテストなどで何
をテストするか（アサーションで何を確認するか）がピンときていないような
感じだったので説明した。

説明の前に、まず、どうしてピンときていないように感じたかをメモしておく。
テスト内に不必要なオブジェクトがでてきていたからピンときていないと感じ
た。例えば、
[コマンドの実行結果オブジェクトのテストでクライアントオブジェクトがでてくる](https://github.com/ranguba/groonga-client/blob/6c658804c5f1347597ab4912a1fd3bcb770ed4d0/test/results/test-table-list.rb#L13)
あたりである。実行結果オブジェクトはクライアントオブジェクトから使われ
ているだけであり、クライアントオブジェクトを使っているわけではない。そ
のため、クライアントを登場させなくても実行結果オブジェクトをテストできる。

あんまりうまく伝えられなかったので、長くなってもちゃんとメモを残してお
きたいところだが、ちゃんとまとめることが難しいので簡単にまとめるだけに
する。アサーションで確認するポイントは以下である。

- そのオブジェクト内で処理が完結している部分は、入力に対して期待した出力があるか
- 完結していないなら、他のオブジェクトを正しく呼び出しているか（モックを使う）

完結している部分は困っていなそうに感じた。

完結していない部分は困っていそうに感じた。他のオブジェクトは別途テスト
しておけば、「正しく呼びだせば正しく動くと期待してもよい」というのがピ
ンときていないのかも。他のオブジェクトとの接点をどこに設定するのがよい
かを見つけるのに苦労しているのかも。どこを接点するかとか、どこまでを
「完結している」と捉えるかかしら。

まぁ、なんか、うまくいかなかった。

## その他

1つのテスト内で複数のアサーションを使っている箇所を1つのテストで1つのア
サーションに分割する変更をしていて、
[デバッグしやすいassert_equalの書き方Add Star](http://www.clear-code.com/blog/2011/2/28.html)
が身についていると感じた。

テストをするところについてはあまりうまく伝えられた気がしないし、実際、
まだあんまりピンときていないように感じる。図を描きながらの説明と処理の
流れを書きながらの説明を試してみたが、どちらもうまくいかなった気がする。
どうすればよりよくなるかはまだわからない。

境界をどこに設定するか視点で考える、がポイントなのかも。そうすれば、何
をテストしようとしているかを明確にできたり、不必要なオブジェクト（境界
の外にあるオブジェクト）がテストに登場しなくなるかも。

[SICPのAbstraction Barriers](http://mitpress.mit.edu/sicp/full-text/sicp/book/node29.html)
までを読んでもらうとまた違うのだろうか。でも、ひとりで読むのはつらいか
も。

とりあえず、テストする箇所をどういった視点で見つけるか（切り分けるか？）
というのは理解することが難しい考えだということがわかってよかった。
